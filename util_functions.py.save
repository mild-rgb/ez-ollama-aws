import json
import requests
import boto3
from requests import get
import time

    

def get_local_ip():
 try:
 	ip = str(get('https://checkip.amazonaws.com').text.strip())
 	ip = ip + "/32"
 	return ip
 except Exception as e:
 	print(e)
 	print("you're not connected to the internet or aws is down")
 	

def get_vpc_id(client, vpc_id=None): #get a specific vpc object if it's available. if it's not, get the default one
    #ec2 = boto3.client('ec2')
    # If a VPC ID is provided, describe that specific VPC
    if vpc_id:
        response = client.describe_vpcs(
            VpcIds=[vpc_id]
        )
    else:
        # Otherwise, get the default VPC by filtering on is-default = true
        response = client.describe_vpcs(
            Filters=[{
                'Name': 'is-default',
                'Values': ['true']
            }]
        )
    
    vpcs = response.get('Vpcs', [])
    
    if not vpcs:
        print("No VPC found.")
        return None
    
    # Return the VPC ID (or list if you want more details)
    selected_vpc = vpcs[0]  # There should only be one default VPC
    return selected_vpc['VpcId']
    
    
def create_and_configure_security_group(unique_name, vpc_id, local_ip, client):
    
    # Create the security group with a description and a friendly name
    response = client.create_security_group(
        Description='Security group allowing SSH and custom TCP traffic',
        GroupName=unique_name,
        VpcId=vpc_id
    )
    
    # Extract the security group ID from the response
    security_group_id = response['GroupId']
    print(f"Security Group Created {security_group_id} in VPC {vpc_id}")
    
    # defining the inbound rules to allow ssh on port 22 and custom TCP on port 8080
    ip_permissions = [
        {
            'IpProtocol': 'tcp',
            'FromPort': 22,
            'ToPort': 22,
            'IpRanges': [{'CidrIp': '0.0.0.0/0'}]  #
        },
        {
            'IpProtocol': 'tcp',
            'FromPort': 8080,
            'ToPort': 8080,
            'IpRanges': [{'CidrIp': '0.0.0.0/0'}] #change this to local ip when in prod
        }
    ]
    
    # Authorize the inbound rules on the security group
    client.authorize_security_group_ingress(
        GroupId=security_group_id,
        IpPermissions=ip_permissions
    )
    print("Inbound rules for SSH and custom TCP added.")
    
    return security_group_id


def get_security_groups_with_inbound_rule(local_ip, client):
    #ec2 = boto3.client('ec2')
    security_groups = []
    next_token = None

    while True:
        params = {
            'Filters': [
                {
                    'Name': 'ip-permission.cidr',
                    'Values': [local_ip]
                }
            ],
            'MaxResults': 1000  # maximum number of results per request
        }
        if next_token:
            params['NextToken'] = next_token #loop through describe_security_groups 

        response = client.describe_security_groups(**params)
        print(response)
        security_groups.extend(response['SecurityGroups'])

        next_token = response.get('NextToken')
        if not next_token:
            break

    return security_groups

def create_ebs_disk(client):
	response = client.create_volume(
    	AvailabilityZone='eu-north-1b',
    	Size=100,
    	VolumeType='gp3',
	)
	diskid = response.get('VolumeId')
	return diskid
    	

format_and_mount =  """
DEVICE=/dev/nvme1n1 && 
sudo udevadm settle &&
sleep 5 &&
sudo wipefs -af $DEVICE &&
sudo parted --script $DEVICE mklabel gpt mkpart primary ext4 0% 100% &&
sudo partprobe $DEVICE &&
sleep 2 &&
sudo mkfs.ext4 ${DEVICE}p1 &&
sudo mkdir -p /home/ubuntu/mnt &&
sudo mount ${DEVICE}p1 /home/ubuntu/mnt
"""


install_ollama = 'curl -fsSL https://ollama.com/install.sh | sh'

install_docker ='sudo apt update && sudo apt install apt-transport-https ca-certificates curl software-properties-common && curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg && echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null && sudo apt update && apt-cache policy docker-ce && sudo apt install docker-ce'

go_to_systemd = 'cd . && cd ../../etc/systemd/system'

install_webui = 'sudo docker pull ghcr.io/open-webui/open-webui:main'

ollama_service = """
[Unit]
Description=Ollama Service
After=network-online.target

[Service]
ExecStart=/usr/local/bin/ollama serve
User=ollama
Group=ollama
Restart=always
RestartSec=3
Environment="PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin"
Environment="OLLAMA_MODELS=/home/ubuntu/mnt/ollama_stuff"

[Install]
WantedBy=default.target"""

#this really should be a singleton tho 
#class AWSSetup:
#	def __init__(self, keyname):


#maybe i should make this a singleton. maybe it might be helpful to be able to handle commands on two objects. maybe this something that i made in my spare time and can't be bothered to learn oop patterns for 

class RunCMD:
    def __init__(self, sshclient):
        self.sshclient = sshclient

    def execute(self, cmd):
        return self.__run_cmd(cmd)

    def exec_until_no_error(self, cmd, err_mesg='', retries=5, delay=2): #use - use if any error messages are allowable. in this particular case, format_and_mount returns version in error, even when it passess succesfully
        for attempt in range(retries):
            result = self.__run_cmd(cmd)
            if err_mesg in result:
                return result
            print(f"try {attempt} failed")
            time.sleep(delay)
        raise RuntimeError(f"command failed after {retries} retries: {cmd}")

    def __run_cmd(self, command):
        print(f"Running: {command}")
        stdin, stdout, stderr = self.sshclient.exec_command(command)
        output = stdout.read().decode()
        error = stderr.read().decode()
        print("Output:", output)
        print("Error:", error)
        return error

    def make_folder(self, name, absolute_path):
        command = 'sudo mkdir ' + absolute_path + '/' + name
        self.__run_cmd(command) 

    def __overwrite_text_into_file(self, text, filename, absolute_path):
        command = 'cd / && ' + 'cd ' + absolute_path + " && echo '" + text + "' | sudo tee " + filename + ' >/dev/null'
        self.__run_cmd(command)

    def overwrite_systemd_file(self, filename, content):
         path_to_systemd = '/etc/systemd/system/'
         self.__overwrite_text_into_file(content, filename, path_to_systemd)
         restart_cmd = 'sudo systemctl daemon-reload && sudo systemctl restart ' + filename
         self.__run_cmd(restart_cmd)
